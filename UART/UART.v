module UART(
	clk16x,
	rst_n,
	 rx,
	DataReady,
	DataReceived);

	//---Ports declearation: generated by Robei---
	input clk16x;
	input rst_n;
	input  rx;
	output DataReady;
	output [7:0] DataReceived;

	wire clk16x;
	wire rst_n;
	wire  rx;
	reg DataReady;
	reg [7:0] DataReceived;

	//----Code starts here: integrated by Robei-----
	 reg [7:0] cnt;
	/*  捕获rx的下降沿，即起始信号  */    
	  reg trigger_r0;
	reg [3:0]count;
	  wire neg_tri;
	always@(posedge clk16x or negedge rst_n)  /*下降沿使用全局时钟来捕获的，其实用clk16x来捕获也可以*/
	  begin
	      if(!rst_n)
	          begin
	             trigger_r0<=1'b0;
	          end
	      else
	         begin    
	              trigger_r0<=rx;
	          end
	  end
	  
	  assign neg_tri = trigger_r0 & ~rx;
	  
	  //----------------------------------------------    
	 /*     counter control      */
	  reg cnt_en;
	  always@(posedge clk16x or negedge rst_n)
	  begin
	      if(!rst_n)
	          cnt_en<=1'b0;
	      else if(neg_tri==1'b1)      /*如果捕获到下降沿，则开始计数*/
	          cnt_en<=1'b1;
	      else if(cnt==8'd152)
	          cnt_en<=1'b0;
	     
	  end
	  //---------------------------------------------
	  /*      counter module ，对采样时钟进行计数       */
	  
	 always@(posedge clk16x or negedge rst_n)
	  begin
	      if(!rst_n)
	          cnt<=8'd0;
	      else if(cnt_en)
	        //  cnt<=cnt+1'b1;
	       cnt<=cnt+1;
	      else
	          cnt<=8'd0;
	  
	  end
	  //---------------------------------------------
	  /*      receive module        */
	  reg StopBit_r;
	  always@(posedge clk16x or negedge rst_n)
	  begin
	      if(!rst_n)
	          begin
	             DataReceived<=8'b0;
	             count=0;
	         end
	      else if(cnt_en)
	          case(cnt)
	              8'd24: begin  DataReceived[0] <= rx; count=count+1;  end  /*在各个采样时刻，读取接收到的数据*/
	              8'd40: begin  DataReceived[1] <= rx; count=count+1;  end
	              8'd56: begin  DataReceived[2] <= rx; count=count+1;  end
	              8'd72: begin  DataReceived[3] <= rx; count=count+1;  end
	              8'd88: begin  DataReceived[4] <= rx; count=count+1;  end
	              8'd104: begin DataReceived[5] <= rx; count=count+1;  end
	              8'd120: begin DataReceived[6] <= rx; count=count+1;  end
	              8'd136: begin DataReceived[7] <= rx; count=count+1;  end
	              
	          endcase
	  
	  end
	  
	  always@(posedge clk16x or negedge rst_n)
	  begin
	      if(!rst_n)
	          DataReady<=1'b0;
	      else if (cnt==8'd152)
	          DataReady<=1'b1;       //接收到停止位后，给出数据准备好标志位
	      else 
	          DataReady<=1'b0;
	  end
	  
	
endmodule    //UART
